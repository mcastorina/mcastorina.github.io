<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ground Up: Bits | miccah.io</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ground Up: Bits" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A website for all my creations, thoughts, and projects. This website will serve as a collection of my interests, ideas, and lessons I have learned over time." />
<meta property="og:description" content="A website for all my creations, thoughts, and projects. This website will serve as a collection of my interests, ideas, and lessons I have learned over time." />
<link rel="canonical" href="/posts/ground-up-bits.html" />
<meta property="og:url" content="/posts/ground-up-bits.html" />
<meta property="og:site_name" content="miccah.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-06-22T05:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ground Up: Bits" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-06-22T05:00:00+00:00","datePublished":"2021-06-22T05:00:00+00:00","description":"A website for all my creations, thoughts, and projects. This website will serve as a collection of my interests, ideas, and lessons I have learned over time.","headline":"Ground Up: Bits","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/ground-up-bits.html"},"url":"/posts/ground-up-bits.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="miccah.io" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">miccah.io</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/knowledge/">Knowledge Base</a><a class="page-link" href="/posts/">Posts</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Ground Up: Bits</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-06-22T05:00:00+00:00" itemprop="datePublished">Jun 22, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js" integrity="sha512-ovjLI1ZcZe6bw+ImQ21r+sv8q/Vwob2kq7tFidK6E1LWfi0T4uobbmpfEU1//a9h9o5Kkt+MnMWf6rWlg0EiMw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<p>Welcome to a new series of posts cleverly titled <strong><em>Ground Up</em></strong>,
where I explain computing concepts from the ground up! We’ll explore
how computers work starting with transistors and going from there.
This post specifically covers transistors, digital logic, and binary.</p>

<ul>
  <li><strong><em>Part 1: Bits</em></strong></li>
  <li><a href="/posts/ground-up-gates.html">Part 2: Gates</a></li>
  <li><a href="/posts/ground-up-memory.html">Part 3: Memory</a></li>
  <li><a href="/posts/ground-up-state-machines.html">Part 4: State Machines</a></li>
</ul>

<h2 id="transistors">Transistors</h2>
<p>At the end of the day, computers are complex circuits built mostly of
transistors. Transistors are electrical components that can be thought
of as gates that allow or deny current to flow. That’s it. Try toggling
the <strong>gate</strong> below to see how the current responds.</p>

<style type="text/css" media="all">
.gate th, td {
    padding: 10px;
}
.gate {
    display: inline-block;
    vertical-align: middle;
    width: unset;
}
p.gate {
    vertical-align: unset;
}
table {
    margin: 30px auto;
}
.table-div {
    padding: 20px;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
    width: 30%;
}
.interactive {
    padding: 20px;
    margin: 20px auto;
    border: 1px dashed gray;
}
.interactive.not { width: 60%; }
.interactive.xor div.table-div {
    width: 40%;
}
canvas {
    display: inline-block;
    vertical-align: middle;
    height: 120px;
}
#not {
    height: 240px;
    width: 210px;
}
#and {
    height: 380px;
    width: 420px;
}
#or {
    height: 380px;
    width: 420px;
}
#xor {
    height: 430px;
    width: 280px;
}
</style>

<script type="text/javascript">
    window.globals = {};
    function updateState(checkbox, global) {
        window.globals[global] = checkbox.checked;
        window.globals.updateNot();
        window.globals.updateAnd();
        window.globals.updateOr();
        window.globals.updateXor();
        updateTables();
    }
    function updateTables() {
        var notTable = document.getElementById("notTable").children[0].children;
        var notIndex = (window.globals.notA ? 1 : 0) + 1;
        for (var i = 1; i < notTable.length; i++) {
            notTable[i].style.backgroundColor = i == notIndex ? 'yellow' : 'white';
        }
        updateTable2("and");
        updateTable2("or");
        updateTable2("xor");
    }
    function updateTable2(prefix) {
        var table = document.getElementById(prefix + "Table").children[0].children;
        var index = (window.globals[prefix + "A"] ? 2 : 0) + (window.globals[prefix + "B"] ? 1 : 0) + 1;
        for (var i = 1; i < table.length; i++) {
            table[i].style.backgroundColor = i == index ? 'yellow' : 'white';
        }
    }
    window.onload = function() {
        window.globals.updateNot();
        window.globals.updateAnd();
        window.globals.updateOr();
        window.globals.updateXor();
        updateTables();
    }
</script>

<script type="text/paperscript" canvas="nchannel">
var path = new CompoundPath();
path.strokeColor = 'black';
path.strokeWidth = 2;
var anchor = new Point(70, 10);

path.moveTo(anchor);
path.lineBy([ 0, 24 ]);
path.lineBy([ -30, 0 ]);
path.lineBy([ 0, 48 ]);
path.lineBy([ 30, 0 ]);
path.lineBy([ 0, 24 ]);

path.moveTo(anchor + [-35, 24]);
path.lineBy([0, 48]);

var gateLength = 24;
path.moveTo(anchor + [-35 - gateLength, 48]);
path.lineBy([gateLength, 0]);

var drain = new PointText({
    point: anchor + [15, 10],
    justification: 'center',
    fontSize: 20,
    content: 'D'
});
var source = new PointText({
    point: anchor + [15, 95],
    justification: 'center',
    fontSize: 20,
    content: 'S'
});

var symbol = new Symbol(new Path.Circle({
    center: [0, 0],
    radius: 2,
    fillColor: 'red'
}));
var dots = new Array();
for (var i = 0; i < 10; i++) {
    dots.push(symbol.place(anchor));
}

function onFrame(event) {
    var runOffset = window.globals.nChannel ? (event.count * 2) : 0;
    var p = path.children[0];
    for (var i = 0; i < dots.length; i++) {
        var dotOffset = 100 * i / dots.length;
        var offset = (runOffset + dotOffset) % 101;
        dots[i].position = p.getPointAt(p.length * offset / 100);
    }
}

</script>

<div class="interactive" style="width: 20%;">
<p class="gate"><input type="checkbox" onclick="updateState(this, 'nChannel');" /><label>G</label></p>
<canvas id="nchannel" style="width: 100px;"></canvas>
</div>

<p>It is from this simple building block we can begin to form more complex
logic. There are two common variants of transistors: P-Channel and
N-Channel. The above is an N-Channel transistor, which means the current
flows when voltage is applied to the Gate (G). A P-Channel transistor
means the current flows when there is <em>no</em> voltage applied to the Gate.</p>

<script type="text/paperscript" canvas="pchannel">
var path = new CompoundPath();
path.strokeColor = 'black';
path.strokeWidth = 2;
var anchor = new Point(70, 10);

path.moveTo(anchor);
path.lineBy([ 0, 24 ]);
path.lineBy([ -30, 0 ]);
path.lineBy([ 0, 48 ]);
path.lineBy([ 30, 0 ]);
path.lineBy([ 0, 24 ]);

path.moveTo(anchor + [-35, 24]);
path.lineBy([0, 48]);

var gateLength = 18;
path.moveTo(anchor + [-41 - gateLength, 48]);
path.lineBy([gateLength, 0]);

var dot = new Path.Circle(anchor + [ -38, 48 ], 3);
dot.strokeColor = 'black';
dot.strokeWidth = 2;

var drain = new PointText({
    point: anchor + [15, 10],
    justification: 'center',
    fontSize: 20,
    content: 'S'
});
var source = new PointText({
    point: anchor + [15, 95],
    justification: 'center',
    fontSize: 20,
    content: 'D'
});

var symbol = new Symbol(new Path.Circle({
    center: [0, 0],
    radius: 2,
    fillColor: 'red'
}));
var dots = new Array();
for (var i = 0; i < 10; i++) {
    dots.push(symbol.place(anchor));
}

function onFrame(event) {
    var runOffset = window.globals.pChannel ? 0 : (event.count * 2);
    var p = path.children[0];
    for (var i = 0; i < dots.length; i++) {
        var dotOffset = 100 * i / dots.length;
        var offset = (runOffset + dotOffset) % 101;
        dots[i].position = p.getPointAt(p.length * offset / 100);
    }
}

</script>

<div class="interactive" style="width: 20%;">
<p class="gate"><input type="checkbox" onclick="updateState(this, 'pChannel');" /><label>G</label></p>
<canvas id="pchannel" style="width: 100px;"></canvas>
</div>

<p>The dot on the input gate indicates negation and is a common symbol in
digital logic. It helps me to remember that the <code class="language-plaintext highlighter-rouge">P</code> in “P-Channel” has
a hole in the letter like the dot on the schematic.</p>

<h2 id="binary-logic">Binary Logic</h2>
<p>Before we start using these building blocks, let’s cover what binary
logic is.  Through the transistor, we have a way to allow current to
flow or not, which can be thought of as two states: on or off. When the
voltage in a circuit is above a threshold, it is considered to be “on”,
and when the voltage is below a threshold, it is “off”. This is the basis
of binary logic: there are only two possible states the circuit can be
in. From here on, we’ll denote “on” with a <code class="language-plaintext highlighter-rouge">1</code> and “off” with a <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p><code class="language-plaintext highlighter-rouge">NOT</code> is the simplest binary operation, involving only a single input. The <code class="language-plaintext highlighter-rouge">NOT</code>
operation will negate its input. If the input is a <code class="language-plaintext highlighter-rouge">1</code>, the output is a <code class="language-plaintext highlighter-rouge">0</code>. If the
input is a <code class="language-plaintext highlighter-rouge">0</code>, the output is a <code class="language-plaintext highlighter-rouge">1</code>. Below is a table of binary operations for your
reference.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Binary Operator</th>
      <th style="text-align: center">Symbol</th>
      <th>Description</th>
      <th>Transition Table</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><b>NOT</b></td>
      <td style="text-align: center">~</td>
      <td>Negate its input</td>
      <td><table><thead><tr><th>A</th><th>Output</th></tr></thead><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></table></td>
    </tr>
    <tr>
      <td style="text-align: center"><b>AND</b></td>
      <td style="text-align: center">&amp;</td>
      <td>Outputs <code class="language-plaintext highlighter-rouge">1</code> if both inputs are <code class="language-plaintext highlighter-rouge">1</code></td>
      <td><table><thead><tr><th>A</th><th>B</th><th>Output</th></tr></thead><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></table></td>
    </tr>
    <tr>
      <td style="text-align: center"><b>OR</b></td>
      <td style="text-align: center">|</td>
      <td>Outputs <code class="language-plaintext highlighter-rouge">1</code> if either input is <code class="language-plaintext highlighter-rouge">1</code></td>
      <td><table><thead><tr><th>A</th><th>B</th><th>Output</th></tr></thead><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></table></td>
    </tr>
    <tr>
      <td style="text-align: center"><b>XOR</b></td>
      <td style="text-align: center">$$\oplus$$</td>
      <td>Outputs <code class="language-plaintext highlighter-rouge">1</code> if its inputs are not equal</td>
      <td><table><thead><tr><th>A</th><th>B</th><th>Output</th></tr></thead><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></table></td>
    </tr>
  </tbody>
</table>

<p>Great! Now you may be wondering why this is useful. Well, you can actually
build a lot of interesting things just from these components alone,
including memory, state machines, and eventually computers.</p>

<h2 id="using-transistors">Using Transistors</h2>
<p>Let’s now build the components that will perform these binary operations
using the only building block we have: transistors! I highly recommend
you try this exercise on your own before seeing how I’ve done it here.</p>

<p><a href="https://www.falstad.com/circuit/">This online simulator</a> is a good
tool you may use.  The components we are using are the N-Channel and
P-Channel MOSFETs (under Active Components).</p>

<p><strong>Electronics Introduction</strong></p>

<p>For those new to electronics, here are a few notes to help you build
the below circuits.</p>

<ul>
  <li>Voltage on a wire does not change</li>
  <li>Circuits generally have a power and ground component
    <ul>
      <li>Do not connect power to ground - your circuit will melt as current
approaches infinity</li>
    </ul>
  </li>
</ul>

<p><strong>Transistor Characteristics</strong></p>

<p>Because N-Channel and P-Channel transistors are electrical components
that abide by the laws of physics, there are some restrictions on
how they can be used in circuits. They are not <em>completely</em> binary
in allowing current to flow or not, and it actually depends on the
“Gate to Source” voltage. The important thing to note is that N-Channel
transistors should source low voltages, and P-Channel transistors should
source high voltages. You will notice in the examples below that all of
the P-Channel transistors are on the “top half” of the circuit and all
of the N-Channel transistors are on the “bottom half” because of this.</p>

<p>This limitation also results in inverse operators being easier to build
than their logical counterparts. To build an AND gate in practice,
it is a NAND gate (NOT-AND) followed by a NOT gate.</p>

<h3 id="not-gate">NOT Gate</h3>

<p>Instructions: toggle the inputs to see how the circuit reacts.</p>

<div class="interactive not">
<div class="table-div"><table class="gate" id="notTable">
    <tr>
        <th><input type="checkbox" onclick="updateState(this, 'notA');" /><label>A</label></th>
        <th>Out</th>
    </tr>
    <tr><td><code>0</code></td><td><code>1</code></td></tr>
    <tr><td><code>1</code></td><td><code>0</code></td></tr>
</table></div>

<script type="text/paperscript" canvas="not">
var scale = 32;
function gatePath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo((anchor + [0, 0.25])*scale);
    path.lineBy(new Point(0, 0.5)*scale);
    return path;
}
function pChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(0.8, 0)*scale);
        path.moveBy(new Point(0.2, -0.5)*scale);
        path.lineBy(new Point(0, 1)*scale);
        var dot = new Path.Circle((anchor + [0.9, 0])*scale, 0.1*scale);
        path.addChild(dot);
        return path;
    }
    path.lineBy(new Point(-0.8, 0)*scale);
    path.moveBy(new Point(-0.2, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    var dot = new Path.Circle((anchor + [-0.9, 0])*scale, 0.1*scale);
    path.addChild(dot);
    return path;
}
function nChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(1, 0)*scale);
    } else {
        path.lineBy(new Point(-1, 0)*scale);
    }
    path.moveBy(new Point(0, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    return path;
}
function notPPath(anchor) {
    return gatePath(anchor + [2.2, 2]);
}
function notNPath(anchor) {
    return gatePath(anchor + [2.2, 5]);
}
function notOutPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 2.75])*scale);
    path.lineTo((anchor + [2.2, 3])*scale);
    path.lineTo((anchor + [3, 3])*scale);
    path.lineBy(new Point(0, 2)*scale);
    path.lineTo((anchor + [2.2, 5])*scale);
    path.lineTo((anchor + [2.2, 5.25])*scale);

    path.moveTo((anchor + [3, 4])*scale);
    path.lineBy(new Point(1, 0)*scale);

    return path;
}
function inputAPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.addChild(pChannelPath(anchor + [1, 2.5], 'LR'));
    path.addChild(nChannelPath(anchor + [1, 5.5], 'LR'));

    path.moveTo((anchor + [1, 2.5])*scale);
    path.lineBy(new Point(0, 3)*scale);
    path.moveTo((anchor + [0, 4])*scale);
    path.lineBy(new Point(1, 0)*scale);

    return path;
}

function drawVdd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'red';
    path.strokeWidth = 2;

    var triangle = new Path.RegularPolygon((anchor + [3, 1])*scale, 3, scale/2.5);
    path.addChild(triangle);

    path.moveTo((anchor + [3, 1 + 1/5])*scale);
    path.lineTo((anchor + [3, 2])*scale);
    path.lineTo((anchor + [2.2, 2])*scale);
    path.lineTo((anchor + [2.2, 2.25])*scale);
}
function drawGnd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 5.75])*scale);
    path.lineTo((anchor + [2.2, 6])*scale);
    path.lineTo((anchor + [3, 6])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveBy(new Point(-0.4, 0)*scale);
    path.lineBy(new Point(0.8, 0)*scale);
    path.moveBy(new Point(-0.1, 0.15)*scale);
    path.lineBy(new Point(-0.6, 0)*scale);
    path.moveBy(new Point(0.1, 0.15)*scale);
    path.lineBy(new Point(0.4, 0)*scale);
}
function drawLabels(anchor) {
    new PointText({
        point: (anchor + [-0.5, 4.25])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [5, 4.25])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'Out'
    });
    new PointText({
        point: (anchor + [4.1, 1.1])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'Vdd'
    });
    new PointText({
        point: (anchor + [4.2, 7.4])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'Gnd'
    });
}

var anchor  = new Point(1, -0.25);
var notP    = notPPath(anchor);
var notN    = notNPath(anchor);
var notOut  = notOutPath(anchor);
var inputA  = inputAPath(anchor);
drawVdd(anchor);
drawGnd(anchor);
drawLabels(anchor);

window.globals.updateNot = function() {
    var a = window.globals.notA;
    notP.strokeColor = !a ? 'red' : 'white';
    notN.strokeColor = a ? 'black' : 'white';
    notOut.strokeColor = !a ? 'red' : 'black';
    inputA.strokeColor = a ? 'red' : 'black';
}

</script>
<canvas id="not" resize=""></canvas>
</div>

<h3 id="and-gate">AND Gate</h3>

<div class="interactive and">
<div class="table-div"><table class="gate" id="andTable">
    <tr>
        <th><input type="checkbox" onclick="updateState(this, 'andA');" /><label>A</label></th>
        <th><input type="checkbox" onclick="updateState(this, 'andB');" /><label>B</label></th>
        <th>Out</th>
    </tr>
    <tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>
    <tr><td><code>0</code></td><td><code>1</code></td><td><code>0</code></td></tr>
    <tr><td><code>1</code></td><td><code>0</code></td><td><code>0</code></td></tr>
    <tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr>
</table></div>

<script type="text/paperscript" canvas="and">
var scale = 32;
function gatePath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo((anchor + [0, 0.25])*scale);
    path.lineBy(new Point(0, 0.5)*scale);
    return path;
}
function pChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(0.8, 0)*scale);
        path.moveBy(new Point(0.2, -0.5)*scale);
        path.lineBy(new Point(0, 1)*scale);
        var dot = new Path.Circle((anchor + [0.9, 0])*scale, 0.1*scale);
        path.addChild(dot);
        return path;
    }
    path.lineBy(new Point(-0.8, 0)*scale);
    path.moveBy(new Point(-0.2, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    var dot = new Path.Circle((anchor + [-0.9, 0])*scale, 0.1*scale);
    path.addChild(dot);
    return path;
}
function nChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(1, 0)*scale);
    } else {
        path.lineBy(new Point(-1, 0)*scale);
    }
    path.moveBy(new Point(0, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    return path;
}
function nandAPPath(anchor) {
    return gatePath(anchor + [1.2, 3]);
}
function nandBPPath(anchor) {
    return gatePath(anchor + [4.8, 3]);
}
function nandANPath(anchor) {
    return gatePath(anchor + [2.2, 7]);
}
function nandBNPath(anchor) {
    return gatePath(anchor + [2.2, 9]);
}
function nandOutPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [1.2, 3.75])*scale);
    path.lineTo((anchor + [1.2, 4])*scale);
    path.lineTo((anchor + [2, 4])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.lineBy(new Point(2, 0)*scale);
    path.lineBy(new Point(0, -1)*scale);
    path.lineTo((anchor + [4.8, 4])*scale);
    path.lineTo((anchor + [4.8, 3.75])*scale);

    path.moveTo((anchor + [2.2, 7.25])*scale);
    path.lineTo((anchor + [2.2, 7])*scale);
    path.lineTo((anchor + [3, 7])*scale);
    path.lineBy(new Point(0, -2)*scale);

    path.moveTo((anchor + [3, 6])*scale);
    path.lineBy(new Point(4, 0)*scale);

    path.moveTo((anchor + [8, 4])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveTo((anchor + [8, 7])*scale);
    path.lineBy(new Point(0, 1)*scale);

    path.moveTo((anchor + [7.8, 4.5])*scale);
    path.lineBy(new Point(-0.8, 0)*scale);
    path.lineBy(new Point(0, 3)*scale);
    path.lineBy(new Point(1, 0)*scale);

    var dot = new Path.Circle((anchor + [7.9, 4.5])*scale, 0.1*scale);
    path.addChild(dot);

    return path;
}
function nandGndPath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 7.75])*scale);
    path.lineTo((anchor + [2.2, 8])*scale);
    path.lineTo((anchor + [3, 8])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.lineTo((anchor + [2.2, 9])*scale);
    path.lineTo((anchor + [2.2, 9.25])*scale);

    return path;
}
function notPPath(anchor) {
    return gatePath(anchor + [8.2, 4]);
}
function notNPath(anchor) {
    return gatePath(anchor + [8.2, 7]);
}
function notOutPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [8.2, 4.75])*scale);
    path.lineTo((anchor + [8.2, 5])*scale);
    path.lineTo((anchor + [9, 5])*scale);
    path.lineBy(new Point(0, 2)*scale);
    path.lineTo((anchor + [8.2, 7])*scale);
    path.lineTo((anchor + [8.2, 7.25])*scale);

    path.moveTo((anchor + [9, 6])*scale);
    path.lineBy(new Point(1, 0)*scale);

    return path;
}
function inputAPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.addChild(pChannelPath(anchor + [0, 3.5], 'LR'));
    path.addChild(nChannelPath(anchor + [1, 7.5], 'LR'));
    return path;
}
function inputBPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.addChild(pChannelPath(anchor + [6, 3.5], 'RL'));
    path.addChild(nChannelPath(anchor + [1, 9.5], 'LR'));
    return path;
}

function drawVdd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'red';
    path.strokeWidth = 2;

    // NAND Vdd
    var triangle1 = new Path.RegularPolygon((anchor + [3, 1])*scale, 3, scale/2.5);
    path.addChild(triangle1);

    path.moveTo((anchor + [3, 1 + 1/5])*scale);
    path.lineBy(new Point(0, 1 - 1/5)*scale);

    path.moveTo((anchor + [1.2, 3.25])*scale);
    path.lineTo((anchor + [1.2, 3])*scale);
    path.lineTo((anchor + [2, 3])*scale);
    path.lineBy(new Point(0, -1)*scale);
    path.lineBy(new Point(2, 0)*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.lineTo((anchor + [4.8, 3])*scale);
    path.lineTo((anchor + [4.8, 3.25])*scale);

    // NOT Vdd
    var triangle2 = new Path.RegularPolygon((anchor + [9, 3])*scale, 3, scale/2.5);
    path.addChild(triangle2);

    path.moveTo((anchor + [9, 3 + 1/5])*scale);
    path.lineTo((anchor + [9, 4])*scale);
    path.lineTo((anchor + [8.2, 4])*scale);
    path.lineTo((anchor + [8.2, 4.25])*scale);
}
function drawGnd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    // NAND Gnd
    path.moveTo((anchor + [2.2, 9.75])*scale);
    path.lineTo((anchor + [2.2, 10])*scale);
    path.lineTo((anchor + [3, 10])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveBy(new Point(-0.4, 0)*scale);
    path.lineBy(new Point(0.8, 0)*scale);
    path.moveBy(new Point(-0.1, 0.15)*scale);
    path.lineBy(new Point(-0.6, 0)*scale);
    path.moveBy(new Point(0.1, 0.15)*scale);
    path.lineBy(new Point(0.4, 0)*scale);

    // NOT Gnd
    path.moveTo((anchor + [8.2, 7.75])*scale);
    path.lineTo((anchor + [8.2, 8])*scale);
    path.lineTo((anchor + [9, 8])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveBy(new Point(-0.4, 0)*scale);
    path.lineBy(new Point(0.8, 0)*scale);
    path.moveBy(new Point(-0.1, 0.15)*scale);
    path.lineBy(new Point(-0.6, 0)*scale);
    path.moveBy(new Point(0.1, 0.15)*scale);
    path.lineBy(new Point(0.4, 0)*scale);
}
function drawLabels(anchor) {
    new PointText({
        point: (anchor + [-0.5, 3.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [6.5, 3.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [0.5, 7.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [0.5, 9.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [11, 6.25])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'Out'
    });
}

var anchor  = new Point(1, 0);
var nandAP  = nandAPPath(anchor);
var nandBP  = nandBPPath(anchor);
var nandAN  = nandANPath(anchor);
var nandBN  = nandBNPath(anchor);
var nandOut = nandOutPath(anchor);
var nandGnd = nandGndPath(anchor);
var notP    = notPPath(anchor);
var notN    = notNPath(anchor);
var notOut  = notOutPath(anchor);
var inputA  = inputAPath(anchor);
var inputB  = inputBPath(anchor);
drawVdd(anchor);
drawGnd(anchor);
drawLabels(anchor);

window.globals.updateAnd = function() {
    var a = window.globals.andA;
    var b = window.globals.andB;
    nandAP.strokeColor = a ? 'white' : 'red';
    nandBP.strokeColor = b ? 'white' : 'red';
    nandAN.strokeColor = a ? (b ? 'black' : 'red') : 'white';
    nandBN.strokeColor = b ? 'black' : 'white';
    nandOut.strokeColor = !(a && b) ? 'red' : 'black';
    nandGnd.strokeColor = b ? 'black' : (a ? 'red' : 'cyan');
    notP.strokeColor = (a && b) ? 'red' : 'white';
    notN.strokeColor = !(a && b) ? 'black' : 'white';
    notOut.strokeColor = a && b ? 'red' : 'black';
    inputA.strokeColor = a ? 'red' : 'black';
    inputB.strokeColor = b ? 'red' : 'black';
}

</script>
<canvas id="and" resize=""></canvas>
</div>

<h3 id="or-gate">OR Gate</h3>

<div class="interactive or">
<div class="table-div"><table class="gate" id="orTable">
    <tr>
        <th><input type="checkbox" onclick="updateState(this, 'orA');" /><label>A</label></th>
        <th><input type="checkbox" onclick="updateState(this, 'orB');" /><label>B</label></th>
        <th>Out</th>
    </tr>
    <tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>
    <tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr>
    <tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr>
    <tr><td><code>1</code></td><td><code>1</code></td><td><code>1</code></td></tr>
</table></div>

<script type="text/paperscript" canvas="or">
var scale = 32;
function gatePath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo((anchor + [0, 0.25])*scale);
    path.lineBy(new Point(0, 0.5)*scale);
    return path;
}
function pChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(0.8, 0)*scale);
        path.moveBy(new Point(0.2, -0.5)*scale);
        path.lineBy(new Point(0, 1)*scale);
        var dot = new Path.Circle((anchor + [0.9, 0])*scale, 0.1*scale);
        path.addChild(dot);
        return path;
    }
    path.lineBy(new Point(-0.8, 0)*scale);
    path.moveBy(new Point(-0.2, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    var dot = new Path.Circle((anchor + [-0.9, 0])*scale, 0.1*scale);
    path.addChild(dot);
    return path;
}
function nChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(1, 0)*scale);
    } else {
        path.lineBy(new Point(-1, 0)*scale);
    }
    path.moveBy(new Point(0, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    return path;
}
function norAPPath(anchor) {
    return gatePath(anchor + [2.2, 2]);
}
function norBPPath(anchor) {
    return gatePath(anchor + [2.2, 4]);
}
function norANPath(anchor) {
    return gatePath(anchor + [1.2, 8]);
}
function norBNPath(anchor) {
    return gatePath(anchor + [4.8, 8]);
}
function norOutPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 4.75])*scale);
    path.lineTo((anchor + [2.2, 5])*scale);
    path.lineTo((anchor + [3, 5])*scale);
    path.lineBy(new Point(0, 2)*scale);

    path.moveTo((anchor + [1.2, 8.25])*scale);
    path.lineTo((anchor + [1.2, 8])*scale);
    path.lineTo((anchor + [2, 8])*scale);
    path.lineBy(new Point(0, -1)*scale);
    path.lineBy(new Point(2, 0)*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.lineTo((anchor + [4.8, 8])*scale);
    path.lineTo((anchor + [4.8, 8.25])*scale);

    path.moveTo((anchor + [3, 6])*scale);
    path.lineBy(new Point(4, 0)*scale);

    path.moveTo((anchor + [8, 4])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveTo((anchor + [8, 7])*scale);
    path.lineBy(new Point(0, 1)*scale);

    path.moveTo((anchor + [7.8, 4.5])*scale);
    path.lineBy(new Point(-0.8, 0)*scale);
    path.lineBy(new Point(0, 3)*scale);
    path.lineBy(new Point(1, 0)*scale);

    var dot = new Path.Circle((anchor + [7.9, 4.5])*scale, 0.1*scale);
    path.addChild(dot);

    return path;
}
function norVddPath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 2.75])*scale);
    path.lineTo((anchor + [2.2, 3])*scale);
    path.lineTo((anchor + [3, 3])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.lineTo((anchor + [2.2, 4])*scale);
    path.lineTo((anchor + [2.2, 4.25])*scale);

    return path;
}
function notPPath(anchor) {
    return gatePath(anchor + [8.2, 4]);
}
function notNPath(anchor) {
    return gatePath(anchor + [8.2, 7]);
}
function notOutPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [8.2, 4.75])*scale);
    path.lineTo((anchor + [8.2, 5])*scale);
    path.lineTo((anchor + [9, 5])*scale);
    path.lineBy(new Point(0, 2)*scale);
    path.lineTo((anchor + [8.2, 7])*scale);
    path.lineTo((anchor + [8.2, 7.25])*scale);

    path.moveTo((anchor + [9, 6])*scale);
    path.lineBy(new Point(1, 0)*scale);

    return path;
}
function inputAPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.addChild(pChannelPath(anchor + [1, 2.5], 'LR'));
    path.addChild(nChannelPath(anchor + [0, 8.5], 'LR'));
    return path;
}
function inputBPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.addChild(pChannelPath(anchor + [1, 4.5], 'LR'));
    path.addChild(nChannelPath(anchor + [6, 8.5], 'RL'));
    return path;
}

function drawVdd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'red';
    path.strokeWidth = 2;

    // NOR Vdd
    var triangle1 = new Path.RegularPolygon((anchor + [3, 1])*scale, 3, scale/2.5);
    path.addChild(triangle1);

    path.moveTo((anchor + [3, 1 + 1/5])*scale);
    path.lineBy(new Point(0, 1 - 1/5)*scale);

    path.moveTo((anchor + [2.2, 2.25])*scale);
    path.lineTo((anchor + [2.2, 2])*scale);
    path.lineTo((anchor + [3, 2])*scale);

    // NOT Vdd
    var triangle2 = new Path.RegularPolygon((anchor + [9, 3])*scale, 3, scale/2.5);
    path.addChild(triangle2);

    path.moveTo((anchor + [9, 3 + 1/5])*scale);
    path.lineTo((anchor + [9, 4])*scale);
    path.lineTo((anchor + [8.2, 4])*scale);
    path.lineTo((anchor + [8.2, 4.25])*scale);
}
function drawGnd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    // NOR Gnd
    path.moveTo((anchor + [1.2, 8.75])*scale);
    path.lineTo((anchor + [1.2, 9])*scale);
    path.lineTo((anchor + [2, 9])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.lineBy(new Point(2, 0)*scale);
    path.lineBy(new Point(0, -1)*scale);
    path.lineTo((anchor + [4.8, 9])*scale);
    path.lineTo((anchor + [4.8, 8.75])*scale);

    path.moveTo((anchor + [3, 10])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveBy(new Point(-0.4, 0)*scale);
    path.lineBy(new Point(0.8, 0)*scale);
    path.moveBy(new Point(-0.1, 0.15)*scale);
    path.lineBy(new Point(-0.6, 0)*scale);
    path.moveBy(new Point(0.1, 0.15)*scale);
    path.lineBy(new Point(0.4, 0)*scale);

    // NOT Gnd
    path.moveTo((anchor + [8.2, 7.75])*scale);
    path.lineTo((anchor + [8.2, 8])*scale);
    path.lineTo((anchor + [9, 8])*scale);
    path.lineBy(new Point(0, 1)*scale);
    path.moveBy(new Point(-0.4, 0)*scale);
    path.lineBy(new Point(0.8, 0)*scale);
    path.moveBy(new Point(-0.1, 0.15)*scale);
    path.lineBy(new Point(-0.6, 0)*scale);
    path.moveBy(new Point(0.1, 0.15)*scale);
    path.lineBy(new Point(0.4, 0)*scale);
}
function drawLabels(anchor) {
    new PointText({
        point: (anchor + [0.5, 2.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [0.5, 4.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [-0.5, 8.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [6.5, 8.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [11, 6.25])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'Out'
    });
}

var anchor  = new Point(1, 0);
var norAP   = norAPPath(anchor);
var norBP   = norBPPath(anchor);
var norAN   = norANPath(anchor);
var norBN   = norBNPath(anchor);
var norOut  = norOutPath(anchor);
var norVdd  = norVddPath(anchor);
var notP    = notPPath(anchor);
var notN    = notNPath(anchor);
var notOut  = notOutPath(anchor);
var inputA  = inputAPath(anchor);
var inputB  = inputBPath(anchor);
drawVdd(anchor);
drawGnd(anchor);
drawLabels(anchor);

window.globals.updateOr = function() {
    var a = window.globals.orA;
    var b = window.globals.orB;
    norAP.strokeColor = a ? 'white' : 'red';
    norBP.strokeColor = b ? 'white' : (a ? 'black' : 'red' );
    norAN.strokeColor = a ? 'black' : 'white';
    norBN.strokeColor = b ? 'black' : 'white';
    norOut.strokeColor = !(a || b) ? 'red' : 'black';
    norVdd.strokeColor = a ? (b ? 'cyan' : 'black') : 'red';
    notP.strokeColor = (a || b) ? 'red' : 'white';
    notN.strokeColor = !(a || b) ? 'black' : 'white';
    notOut.strokeColor = (a || b) ? 'red' : 'black';
    inputA.strokeColor = a ? 'red' : 'black';
    inputB.strokeColor = b ? 'red' : 'black';
}

</script>
<canvas id="or" resize=""></canvas>
</div>

<h3 id="xor-gate">XOR Gate</h3>

<div class="interactive xor">
<div class="table-div">
<table class="gate" id="xorTable">
    <tr>
        <th><input type="checkbox" onclick="updateState(this, 'xorA');" /><label>A</label></th>
        <th><input type="checkbox" onclick="updateState(this, 'xorB');" /><label>B</label></th>
        <th>Out</th>
    </tr>
    <tr><td><code>0</code></td><td><code>0</code></td><td><code>0</code></td></tr>
    <tr><td><code>0</code></td><td><code>1</code></td><td><code>1</code></td></tr>
    <tr><td><code>1</code></td><td><code>0</code></td><td><code>1</code></td></tr>
    <tr><td><code>1</code></td><td><code>1</code></td><td><code>0</code></td></tr>
</table>
<p>Note: The bars over the label indicates negation. For simplicity I removed the transistors to calculate that from A and B.</p>
</div>

<script type="text/paperscript" canvas="xor">
var scale = 32;
function gatePath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo((anchor + [0, 0.25])*scale);
    path.lineBy(new Point(0, 0.5)*scale);
    return path;
}
function pChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(0.8, 0)*scale);
        path.moveBy(new Point(0.2, -0.5)*scale);
        path.lineBy(new Point(0, 1)*scale);
        var dot = new Path.Circle((anchor + [0.9, 0])*scale, 0.1*scale);
        path.addChild(dot);
        return path;
    }
    path.lineBy(new Point(-0.8, 0)*scale);
    path.moveBy(new Point(-0.2, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    var dot = new Path.Circle((anchor + [-0.9, 0])*scale, 0.1*scale);
    path.addChild(dot);
    return path;
}
function nChannelPath(anchor, direction) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.moveTo(anchor*scale);
    if (direction == 'LR') {
        path.lineBy(new Point(1, 0)*scale);
    } else {
        path.lineBy(new Point(-1, 0)*scale);
    }
    path.moveBy(new Point(0, -0.5)*scale);
    path.lineBy(new Point(0, 1)*scale);
    return path;
}
function aPPath(anchor) {
    return gatePath(anchor + [2.2, 3]);
}
function naPPath(anchor) {
    return gatePath(anchor + [5.8, 3]);
}
function bPPath(anchor) {
    return gatePath(anchor + [5.8, 5]);
}
function nbPPath(anchor) {
    return gatePath(anchor + [2.2, 5]);
}
function aNPath(anchor) {
    return gatePath(anchor + [2.2, 8]);
}
function naNPath(anchor) {
    return gatePath(anchor + [5.8, 8]);
}
function bNPath(anchor) {
    return gatePath(anchor + [2.2, 10]);
}
function nbNPath(anchor) {
    return gatePath(anchor + [5.8, 10]);
}

function anbPath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 3.75])*scale);
    path.lineTo((anchor + [2.2, 4])*scale);
    path.lineTo((anchor + [3, 4])*scale);
    path.lineTo((anchor + [3, 5])*scale);
    path.lineTo((anchor + [2.2, 5])*scale);
    path.lineTo((anchor + [2.2, 5.25])*scale);
    return path;
}
function nabPath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [5.8, 3.75])*scale);
    path.lineTo((anchor + [5.8, 4])*scale);
    path.lineTo((anchor + [5, 4])*scale);
    path.lineTo((anchor + [5, 5])*scale);
    path.lineTo((anchor + [5.8, 5])*scale);
    path.lineTo((anchor + [5.8, 5.25])*scale);
    return path;
}
function abPath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 8.75])*scale);
    path.lineTo((anchor + [2.2, 9])*scale);
    path.lineTo((anchor + [3, 9])*scale);
    path.lineTo((anchor + [3, 10])*scale);
    path.lineTo((anchor + [2.2, 10])*scale);
    path.lineTo((anchor + [2.2, 10.25])*scale);
    return path;
}
function nanbPath(anchor) {
    var path = new Path();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [5.8, 8.75])*scale);
    path.lineTo((anchor + [5.8, 9])*scale);
    path.lineTo((anchor + [5, 9])*scale);
    path.lineTo((anchor + [5, 10])*scale);
    path.lineTo((anchor + [5.8, 10])*scale);
    path.lineTo((anchor + [5.8, 10.25])*scale);
    return path;
}

function outPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 5.75])*scale);
    path.lineTo((anchor + [2.2, 6])*scale);
    path.lineTo((anchor + [3, 6])*scale);
    path.lineTo((anchor + [3, 8])*scale);
    path.lineTo((anchor + [2.2, 8])*scale);
    path.lineTo((anchor + [2.2, 8.25])*scale);

    path.moveTo((anchor + [5.8, 5.75])*scale);
    path.lineTo((anchor + [5.8, 6])*scale);
    path.lineTo((anchor + [5, 6])*scale);
    path.lineTo((anchor + [5, 8])*scale);
    path.lineTo((anchor + [5.8, 8])*scale);
    path.lineTo((anchor + [5.8, 8.25])*scale);

    path.moveTo((anchor + [3, 7])*scale);
    path.lineBy(new Point(4, 0)*scale);
    return path;
}
function inputAPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.addChild(pChannelPath(anchor + [1, 3.5], 'LR'));
    path.addChild(nChannelPath(anchor + [1, 8.5], 'LR'));
    return path;
}
function inputNAPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.addChild(pChannelPath(anchor + [7, 3.5], 'RL'));
    path.addChild(nChannelPath(anchor + [7, 8.5], 'RL'));
    return path;
}
function inputBPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.addChild(pChannelPath(anchor + [7, 5.5], 'RL'));
    path.addChild(nChannelPath(anchor + [1, 10.5], 'LR'));
    return path;
}
function inputNBPath(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;
    path.addChild(pChannelPath(anchor + [1, 5.5], 'LR'));
    path.addChild(nChannelPath(anchor + [7, 10.5], 'RL'));
    return path;
}

function drawVdd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'red';
    path.strokeWidth = 2;

    var triangle = new Path.RegularPolygon((anchor + [4, 1])*scale, 3, scale/2.5);
    path.addChild(triangle);

    path.moveTo((anchor + [4, 1 + 1/5])*scale);
    path.lineBy(new Point(0, 1 - 1/5)*scale);

    path.moveTo((anchor + [2.2, 3.25])*scale);
    path.lineTo((anchor + [2.2, 3])*scale);
    path.lineTo((anchor + [3, 3])*scale);
    path.lineTo((anchor + [3, 2])*scale);
    path.lineTo((anchor + [5, 2])*scale);
    path.lineTo((anchor + [5, 3])*scale);
    path.lineTo((anchor + [5.8, 3])*scale);
    path.lineTo((anchor + [5.8, 3.25])*scale);
}
function drawGnd(anchor) {
    var path = new CompoundPath();
    path.strokeColor = 'black';
    path.strokeWidth = 2;

    path.moveTo((anchor + [2.2, 10.75])*scale);
    path.lineTo((anchor + [2.2, 11])*scale);
    path.lineTo((anchor + [3, 11])*scale);
    path.lineTo((anchor + [3, 12])*scale);
    path.lineTo((anchor + [5, 12])*scale);
    path.lineTo((anchor + [5, 11])*scale);
    path.lineTo((anchor + [5.8, 11])*scale);
    path.lineTo((anchor + [5.8, 10.75])*scale);

    path.moveTo((anchor + [4, 12])*scale);
    path.lineBy(new Point(0, 1 - 1/5)*scale);
    path.moveBy(new Point(-0.4, 0)*scale);
    path.lineBy(new Point(0.8, 0)*scale);
    path.moveBy(new Point(-0.1, 0.15)*scale);
    path.lineBy(new Point(-0.6, 0)*scale);
    path.moveBy(new Point(0.1, 0.15)*scale);
    path.lineBy(new Point(0.4, 0)*scale);
}
function drawLabels(anchor) {
    new PointText({
        point: (anchor + [0.5, 3.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [0.5, 8.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [7.5, 3.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [7.5, 8.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [0.5, 10.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [7.5, 5.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });

    // negated labels
    new PointText({
        point: (anchor + [7.5, 3.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [7.5, 8.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'A'
    });
    new PointText({
        point: (anchor + [0.5, 5.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [7.5, 10.75])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'B'
    });
    new PointText({
        point: (anchor + [8, 7.25])*scale,
        justification: 'center',
        fontSize: 20,
        content: 'Out'
    });
    var bars = new CompoundPath();
    bars.strokeColor = 'black';
    bars.strokeWidth = 2;
    bars.moveTo((anchor + [7.3, 3.2])*scale);
    bars.lineBy(new Point(0.4, 0)*scale);
    bars.moveTo((anchor + [7.3, 8.2])*scale);
    bars.lineBy(new Point(0.4, 0)*scale);
    bars.moveTo((anchor + [0.3, 5.2])*scale);
    bars.lineBy(new Point(0.4, 0)*scale);
    bars.moveTo((anchor + [7.3, 10.2])*scale);
    bars.lineBy(new Point(0.4, 0)*scale);
}

var anchor  = new Point(0, 0);
var aP = aPPath(anchor);
var naP = naPPath(anchor);
var bP = bPPath(anchor);
var nbP = nbPPath(anchor);
var aN = aNPath(anchor);
var naN = naNPath(anchor);
var bN = bNPath(anchor);
var nbN = nbNPath(anchor);

var anb = anbPath(anchor);
var nab = nabPath(anchor);
var ab = abPath(anchor);
var nanb = nanbPath(anchor);
var out = outPath(anchor);

var inputA = inputAPath(anchor);
var inputNA = inputNAPath(anchor);
var inputB = inputBPath(anchor);
var inputNB = inputNBPath(anchor);
drawVdd(anchor);
drawGnd(anchor);
drawLabels(anchor);

window.globals.updateXor = function() {
    var a = window.globals.xorA;
    var b = window.globals.xorB;

    out.strokeColor = a ^ b ? 'red' : 'black';

    aP.strokeColor = a ? 'white' : 'red';
    naP.strokeColor = !a ? 'white' : 'red';
    bP.strokeColor = b ? 'white' : out.strokeColor;
    nbP.strokeColor = !b ? 'white' : out.strokeColor;
    aN.strokeColor = a ? out.strokeColor : 'white';
    naN.strokeColor = !a ? out.strokeColor : 'white';
    bN.strokeColor = b ? 'black' : 'white';
    nbN.strokeColor = !b ? 'black' : 'white';

    anb.strokeColor = !a ? 'red' : (!b ? 'cyan' : 'black');
    nab.strokeColor = a ? 'red' : (b ? 'cyan' : 'black');
    ab.strokeColor = b ? 'black' : (!a ? 'cyan' : 'red');
    nanb.strokeColor = !b ? 'black' : (a ? 'cyan' : 'red');

    inputA.strokeColor = a ? 'red' : 'black';
    inputNA.strokeColor = !a ? 'red' : 'black';
    inputB.strokeColor = b ? 'red' : 'black';
    inputNB.strokeColor = !b ? 'red' : 'black';
}

</script>
<canvas id="xor" resize=""></canvas>
</div>

<h2 id="more-bits">More Bits</h2>
<p>Just as a note, these components operate on at most 2 bits, where a bit
is a <code class="language-plaintext highlighter-rouge">1</code> or a <code class="language-plaintext highlighter-rouge">0</code>.  As we build components up, we will want to work on
larger groupings of bits, and it should be known that these operations
can be applied in a bitwise fashion. You can <code class="language-plaintext highlighter-rouge">AND</code> two 4-bit inputs by
using the <code class="language-plaintext highlighter-rouge">AND</code> operation on each pair of bits. For example <code class="language-plaintext highlighter-rouge">0110 AND
1100</code> would be <code class="language-plaintext highlighter-rouge">0100</code>.</p>

<table style="width: 50%;">
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Bit 3</th>
      <th style="text-align: center">Bit 2</th>
      <th style="text-align: center">Bit 1</th>
      <th style="text-align: center">Bit 0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>A</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">1</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">1</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>B</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">1</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">1</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Output</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">1</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
  </tbody>
</table>

<h2 id="conclusion">Conclusion</h2>
<p>This post covered the very basics of computers: transistors, digital
logic, and binary operators. If any parts were unclear, please feel
free to contact me.</p>

<p><a href="/posts/ground-up-gates.html">Take me to the next part!</a></p>

<script>updateTables();</script>


  </div><a class="u-url" href="/posts/ground-up-bits.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">miccah.io</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">miccah.io</li><li><a class="u-email" href="mailto:contact@miccah.io">contact@miccah.io</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/mcastorina"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mcastorina</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A website for all my creations, thoughts, and projects. This website will serve as a collection of my interests, ideas, and lessons I have learned over time.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
