<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Ones and Zeros | miccah.io</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Ones and Zeros" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The root of digital logic is being able to differentiate between something and not something. This little seed has basically built the entirety of the information age. You’ve probably heard it before: a computer is just ones and zeros, but let’s explore this a bit (ha) in the context of programming and data." />
<meta property="og:description" content="The root of digital logic is being able to differentiate between something and not something. This little seed has basically built the entirety of the information age. You’ve probably heard it before: a computer is just ones and zeros, but let’s explore this a bit (ha) in the context of programming and data." />
<link rel="canonical" href="/posts/ones-and-zeros.html" />
<meta property="og:url" content="/posts/ones-and-zeros.html" />
<meta property="og:site_name" content="miccah.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-10-23T05:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Ones and Zeros" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-23T05:00:00+00:00","datePublished":"2022-10-23T05:00:00+00:00","description":"The root of digital logic is being able to differentiate between something and not something. This little seed has basically built the entirety of the information age. You’ve probably heard it before: a computer is just ones and zeros, but let’s explore this a bit (ha) in the context of programming and data.","headline":"Ones and Zeros","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/ones-and-zeros.html"},"url":"/posts/ones-and-zeros.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="miccah.io" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">miccah.io</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/knowledge/">Knowledge Base</a><a class="page-link" href="/posts/">Posts</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Ones and Zeros</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-10-23T05:00:00+00:00" itemprop="datePublished">Oct 23, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The root of digital logic is being able to differentiate between <em>something</em>
and <em>not something</em>. This little seed has basically built the entirety of the
information age. You’ve probably heard it before: a computer is just ones and
zeros, but let’s explore this a bit (ha) in the context of programming and
data.</p>

<h3 id="bits-of-data">Bits of Data</h3>

<p>Data ultimately comprises of ones and zeros (called bits) stored in memory, and
we can manipulate how it is represented using different types in a programming
language. Let’s look at an example in C.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Print data as a signed 8-bit decimal number.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"int8_t:  %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

    <span class="c1">// Print data as an unsigned 8-bit decimal number.</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"uint8_t: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int8_t:  -1
uint8_t: 255
</code></pre></div></div>

<p>Let’s break down what’s happening here.</p>

<p>First we create a variable <code class="language-plaintext highlighter-rouge">data</code> that is 1 byte (8 bits) large and
store <code class="language-plaintext highlighter-rouge">-1</code> into it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int8_t</span> <span class="n">data</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>But what is <code class="language-plaintext highlighter-rouge">-1</code>? Well, most computers represent <code class="language-plaintext highlighter-rouge">-1</code> in ones and zeros as all
1s in a thing called <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s compliment</a>. That’s sort of out of scope for this
post, but the gist is that representing negative numbers this way makes binary
addition and subtraction all make sense.</p>

<p>Anyway, since the variable is 1 byte large, the bits will be 8 ones: <code class="language-plaintext highlighter-rouge">11111111</code>.</p>

<p>We then tell <code class="language-plaintext highlighter-rouge">printf</code> to print this data in two different ways: as a signed
integer and as an unsigned integer.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"int8_t:  %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"uint8_t: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
</code></pre></div></div>

<p>The whole <code class="language-plaintext highlighter-rouge">*(uint8_t*)&amp;data</code> is a bit strange if you’re unfamiliar with C, but
here’s what it’s doing (from right to left).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&amp;data       : Take the address of data (this is a pointer)
(uint8_t*)  : Ignore whatever type that pointer was pointing to, you're
              now pointing to a uint8_t type
*           : Get the actual data that we are pointing at as a uint8_t
</code></pre></div></div>

<p>So that’s cool and all, but like, why not just make a new variable and assign
it the value of <code class="language-plaintext highlighter-rouge">data</code>? Well, the point I’m trying to make is the underlying
data is the same. There’s no hidden conversions happening. We are only changing
how the program interprets the ones and zeros.</p>

<h3 id="floating-around">Floating Around</h3>

<p>Let’s take this a step further. Did you know <code class="language-plaintext highlighter-rouge">float</code> in C is 32 bits?</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">1337</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"float:    %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"uint32_t: 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>float:    1337.000000
uint32_t: 0x44a72000
</code></pre></div></div>

<p>The keen reader will notice that <code class="language-plaintext highlighter-rouge">0x44a72000</code> is not equal to <code class="language-plaintext highlighter-rouge">1337</code> at all.
Or, it is, but in a different interpretation? You see, <code class="language-plaintext highlighter-rouge">0x44a72000</code> is the
<a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE floating point</a> representation for <code class="language-plaintext highlighter-rouge">1337.0</code>. Those are the underlying
ones and zeros for that number, so while those specific underlying ones and
zeros are unequal to <code class="language-plaintext highlighter-rouge">1337</code>, taking those ones and zeros as an IEEE floating
point number means it <em>is</em> equal to <code class="language-plaintext highlighter-rouge">1337.0</code>.</p>

<p>Wow that made no sense at all. Here, just stare at this until you become one
with the universe.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint32_t</span> <span class="n">data</span> <span class="o">=</span> <span class="mh">0x44a72000</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1337</span><span class="p">.</span><span class="mi">0</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">data</span> <span class="o">?</span> <span class="s">"true"</span> <span class="o">:</span> <span class="s">"false"</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>true
</code></pre></div></div>

<p>This manipulation of floating points by its underlying bits is
probably most famous from the <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">fast inverse square root</a> function in
<em>Quake</em>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i</span>  <span class="o">=</span> <span class="o">*</span> <span class="p">(</span> <span class="kt">long</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>           <span class="c1">// evil floating point bit level hacking</span>
<span class="n">i</span>  <span class="o">=</span> <span class="mh">0x5f3759df</span> <span class="o">-</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">);</span>   <span class="c1">// what the fuck?</span>
</code></pre></div></div>

<p>All this to say, how we interpret data is kind of arbitrary. Standards
were made to facilitate interoperability and communications. <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a> is one
such standard developed by Bell Labs in the 1960s.</p>

<p>Actually, this “interpretation is in the eye of the beholder” is the idea
behind <a href="https://en.wikipedia.org/wiki/Deniable_encryption">deniable encryption</a>.</p>

<blockquote>
  <p>Deniable encryption makes it impossible to prove
the existence of the plaintext message without the proper decryption key. This
may be done by allowing an encrypted message to be decrypted to different
sensible plaintexts, depending on the key used. This allows the sender to have
plausible deniability if compelled to give up their encryption key.</p>
</blockquote>

<p>Okay, it’s not <em>exactly</em> the same, but the gist is that a collection of bits
can be interpreted in more than one way. Speaking of which, I’m just going to
leave these floats here..</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x1.dcde86p+79
0x1.e8c2e4p+107
0x1.e8c2d8p+83
0x1.e6dcdep-61
0x1.e8d04p+105
0x1.74e6ep-33
0x1.d2da5ep+71
0x1.d0c2c6p-35
0x1.5eded2p+67
0x1.cae6e6p+105
0x1.da5ee6p+115
0x1.cae8e6p+101
0x1.e65af2p+95
0x1.caecd8p+73
0x1.dce05cp+79
</code></pre></div></div>

<details>
<summary>Hint</summary>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">"Wouldn't you like to know, weather boy?</span><span class="se">\0\0\0</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span> <span class="o">*</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%a</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

</details>
<p></p>

<h3 id="conclusion">Conclusion</h3>

<p>Understanding the underlying ones and zeros of data in your program isn’t
always important, but it is certainly nice to know for high performance or
memory-constrained systems. Manipulating the interpretation of data like this
is weirdly one of my favorite stupid things to do in C. I love that you can
peel back the veil and see through the matrix at what the data really is,
however pointless that might be.</p>

<p><strong>P.S.</strong> After writing this post, I realized a C <code class="language-plaintext highlighter-rouge">union</code> might’ve been a better
choice for demonstrating “the data is the same and the interpretation is
different” because that’s literally the whole point of <code class="language-plaintext highlighter-rouge">union</code>!</p>

  </div><a class="u-url" href="/posts/ones-and-zeros.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">miccah.io</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">miccah.io</li><li><a class="u-email" href="mailto:contact@miccah.io">contact@miccah.io</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/mcastorina"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">mcastorina</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A website for all my creations, thoughts, and projects. This website will serve as a collection of my interests, ideas, and lessons I have learned over time.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
